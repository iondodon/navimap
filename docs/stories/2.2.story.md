# Story 2.2: Route Calculation and Display

## Status

Ready for Review

## Story

**As a** user,
**I want** to see the shortest car route from my location to my destination,
**so that** I can understand the optimal path to drive.

## Acceptance Criteria

1. Route calculated using OSRM API when destination is set (FR5)
2. Route displayed as colored polyline overlay on map (FR6)
3. Route calculation completes within 5 seconds (NFR3)
4. GraphHopper API configured as fallback option (FR11)
5. Route automatically recalculates when new destination is set (FR7)
6. Route optimized for car navigation
7. All API calls made over HTTPS (NFR7)

## Tasks / Subtasks

- [x] Task 1: Create Route Data Model (AC: 2)

  - [x] Create lib/models/route.dart with polyline points and metadata
  - [x] Add List<LatLng> points field for route coordinates
  - [x] Include distance (meters) and duration (seconds) fields
  - [x] Add distanceKm and durationMin helper getters for display
  - [x] Include optional geometry field for encoded polyline data

- [x] Task 2: Implement RoutingService with OSRM Integration (AC: 1, 3, 6, 7)

  - [x] Create lib/services/routing_service.dart class
  - [x] Implement calculateRoute(UserLocation, Destination) main method
  - [x] Add \_fetchRouteFromOSRM() private method with HTTPS API calls
  - [x] Configure OSRM request: /route/v1/driving/ with proper parameters
  - [x] Parse OSRM JSON response to Route model
  - [x] Handle API response within 5-second timeout (NFR3)
  - [x] Add proper error handling for OSRM API failures

- [x] Task 3: Add GraphHopper Fallback Implementation (AC: 4, 7)

  - [x] Add \_fetchRouteFromGraphHopper() private method
  - [x] Configure GraphHopper API with car vehicle type
  - [x] Implement fallback logic: OSRM fails → try GraphHopper
  - [x] Parse GraphHopper response format to Route model
  - [x] Handle GraphHopper API key configuration (environment variable)
  - [x] Add timeout and error handling for GraphHopper calls

- [x] Task 4: Integrate Route State with AppState (AC: 5)

  - [x] Add Route? currentRoute field to AppState
  - [x] Implement setRoute(Route) method with notifyListeners()
  - [x] Add route loading states (isCalculatingRoute boolean)
  - [x] Add route error states for API failures
  - [x] Clear route when destination changes before new calculation
  - [x] Trigger route calculation automatically when destination is set

- [x] Task 5: Display Route Polyline on MapScreen (AC: 2)

  - [x] Add PolylineLayer to FlutterMap for route display
  - [x] Configure polyline appearance: blue color, appropriate width
  - [x] Render route points as smooth polyline overlay
  - [x] Ensure polyline visibility across different zoom levels
  - [x] Handle polyline updates when route changes
  - [x] Add loading indicator during route calculation

- [x] Task 6: Route Calculation Workflow Integration (AC: 1, 5, 7)
  - [x] Wire destination selection to automatic route calculation
  - [x] Show loading state during API calls
  - [x] Display calculated route immediately when received
  - [x] Clear previous route when new destination is selected
  - [x] Handle route calculation errors with user feedback
  - [x] Test complete workflow: tap destination → calculate → display route

## Dev Notes

### Route Data Model Requirements

[Source: architecture/data-models.md#route]

- **Route Class**: List<LatLng> points, double distance/duration, optional String geometry
- **Helper Methods**: distanceKm getter (distance/1000 with 1 decimal), durationMin getter (duration/60 rounded)
- **Coordinate Format**: LatLng points array for flutter_map polyline rendering
- **Metadata**: Distance in meters, duration in seconds for consistent units

### RoutingService Architecture

[Source: architecture/components.md#routingservice]

- **Responsibility**: Route calculation via external APIs, fallback logic, response parsing, error handling
- **Key Interfaces**:
  - Future<Route> calculateRoute(UserLocation start, Destination end) - main calculation
  - Future<Route> \_fetchRouteFromOSRM() - OSRM API integration (private)
  - Future<Route> \_fetchRouteFromGraphHopper() - GraphHopper fallback (private)
- **Dependencies**: http package for API calls, AppState for state management
- **Technology**: Dart async/await, HTTP client, JSON parsing

### OSRM API Integration

[Source: architecture/api-specification.md#osrm-api]

- **Base URL**: https://router.project-osrm.org
- **Endpoint**: GET /route/v1/driving/{lon1},{lat1};{lon2},{lat2}
- **Parameters**: overview=full&geometries=geojson for complete route coordinates
- **Response Format**: JSON with routes[0].geometry.coordinates as [lon,lat] array
- **Authentication**: None required (public demo server)
- **Rate Limits**: Fair use policy, no hard limits

### GraphHopper Fallback Configuration

[Source: architecture/api-specification.md#graphhopper-api]

- **Base URL**: https://graphhopper.com/api/1
- **Endpoint**: GET /route with point parameters and vehicle=car
- **API Key**: Required, free tier 500 requests/day
- **Response Format**: paths[0].points.coordinates as [lon,lat] array
- **Fallback Logic**: Try OSRM first, fallback to GraphHopper on failure
- **Timeout**: Both APIs must respond within 5-second total limit (NFR3)

### Core Workflow Implementation

[Source: architecture/core-workflows.md#workflow-2]

- **Route Calculation Sequence**:
  1. User taps destination → AppState.setDestination()
  2. MapScreen triggers RoutingService.calculateRoute()
  3. AppState.setLoadingRoute(true) → show loading indicator
  4. API call (OSRM primary, GraphHopper fallback)
  5. AppState.setRoute(Route) → Consumer rebuilds → polyline renders
- **Performance Target**: Route calculation within 5 seconds (NFR3)

### State Management Integration

[Source: architecture/components.md#appstate]

- **AppState Extension**: Add Route? currentRoute, bool isCalculatingRoute fields
- **Route Methods**: setRoute(Route), clearRoute(), setLoadingRoute(bool)
- **Automatic Triggering**: Route calculation triggered when destination changes
- **Consumer Pattern**: MapScreen Consumer<AppState> rebuilds for route display

### MapScreen Integration

[Source: architecture/components.md#mapscreen]

- **PolylineLayer**: Add to FlutterMap for route visualization
- **Polyline Styling**: Blue color, 4px width, rounded ends
- **Layer Ordering**: Route polyline below location/destination markers
- **Loading States**: Show progress indicator during route calculation
- **Error Handling**: Display error messages for calculation failures

### API Security and Performance

[Source: architecture/api-specification.md]

- **HTTPS Requirement**: All API calls over HTTPS (NFR7)
- **Timeout Configuration**: 5-second maximum for route calculation (NFR3)
- **Error Handling**: Graceful fallback from OSRM to GraphHopper
- **Rate Limiting**: Comply with service usage policies
- **API Key Management**: Secure storage of GraphHopper API key

### HTTP Client Configuration

[Source: architecture/tech-stack.md]

- **Package**: http 1.2.0 (official Dart package)
- **Timeout Settings**: Configure client timeout for 5-second requirement
- **Error Handling**: Network errors, API errors, timeout errors
- **JSON Parsing**: Parse API responses to Route model objects
- **User Agent**: Appropriate User-Agent header for API compliance

## Testing

### Unit Testing Requirements

[Source: architecture/testing-strategy.md]

- **Model Tests**: test/models/route_test.dart for distance/duration helpers
- **Service Tests**: test/services/routing_service_test.dart with mocked HTTP client
- **API Tests**: Mock OSRM and GraphHopper responses, test fallback logic
- **State Tests**: test/state/app_state_test.dart for route state management

### API Integration Testing

[Source: architecture/testing-strategy.md]

- **Mock HTTP Client**: Use mockito to mock http.Client for consistent testing
- **OSRM Response Mocking**: Mock successful OSRM JSON response parsing
- **GraphHopper Fallback**: Test OSRM failure → GraphHopper success scenario
- **Error Scenarios**: Test both APIs failing, timeout handling, network errors
- **Performance Testing**: Verify 5-second timeout compliance

### Widget Testing

[Source: architecture/testing-strategy.md]

- **MapScreen Tests**: Verify PolylineLayer rendering with route data
- **Loading States**: Test loading indicator display during route calculation
- **Consumer Tests**: Verify MapScreen rebuilds when AppState route changes
- **Error Display**: Test error message rendering for route calculation failures

### Integration Testing

- **Route Workflow**: Full destination selection → route calculation → display
- **Fallback Testing**: OSRM unavailable → GraphHopper fallback → route display
- **Performance Verification**: End-to-end route calculation within 5 seconds
- **Cross-Platform**: Test API integration on both Android and iOS

### Manual Testing Checklist

- [ ] Route calculation starts immediately when destination is set
- [ ] Blue polyline appears on map showing driving route
- [ ] Route calculation completes within 5 seconds
- [ ] Route updates when new destination is selected
- [ ] Fallback to GraphHopper works when OSRM is unavailable
- [ ] Loading indicator shows during route calculation
- [ ] Error messages display appropriately for API failures
- [ ] Route polyline is clearly visible across different zoom levels

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-11-11 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Task Notes

- Task 1: Implemented dedicated `Route` model with distance/duration helpers and unit coverage.
- Task 2: Delivered OSRM-backed `RoutingService` with timeout handling and request parsing tests.
- Task 2: Delivered OSRM-backed `RoutingService` with timeout handling and request parsing tests, reserving fallback budget so GraphHopper executes within the 5-second SLA.
- Task 3: Added GraphHopper fallback with shared timeout budgeting and API key validation tests.
- Task 4: Extended `AppState` with route state management, async workflow triggers, and regression tests.
- Task 5: Wired map polyline, status overlays, and info card with widget coverage for route display states.
- Task 6: Validated tap-to-route workflow with loading, success, and error UI paths plus widget coverage.

### Debug Log References

- None.

### Completion Notes

- Added `Route` domain model matching architecture metadata requirements.
- Authored unit tests covering helper getters and copy semantics.
- Created `RoutingService` leveraging OSRM endpoints with resilient error handling and request validation coverage.
- Extended routing service with GraphHopper fallback, enforcing HTTPS usage, API key requirements, and end-to-end test coverage.
- Integrated routing workflow into `AppState`, covering loading/error states, cancellation safeguards, and location-triggered recalculations with tests.
- Updated `MapScreen` to render route overlays, status banners, and summary card with widget tests validating loading and success states.
- Exercised full routing workflow via widget tests, including tap-driven requests, success UI, and error handling banners.
- Stubbed OpenStreetMap tile access in widget tests to eliminate external HTTP calls and added regression coverage for OSRM timeout fallbacks.

### File List

- lib/models/route.dart
- test/models/route_test.dart
- lib/services/routing_service.dart
- test/services/routing_service_test.dart
- lib/state/app_state.dart
- test/state/app_state_test.dart
- lib/screens/map_screen.dart
- test/screens/map_screen_test.dart

### Agent Model Used

- GitHub Copilot (GPT-5-Codex)

## QA Results

_This section will be populated during QA review_

### Review Date: 2025-11-12

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

- Primary routing flow passes under nominal conditions, but fallback timing leaves users without a route when OSRM stalls and widget tests rely on live tile servers, creating reliability gaps.
- Implementation otherwise tracks architectural guidance (HTTPS-only APIs, car-mode routing, state segregation) and code is clear with strong async error handling.
- Automated coverage spans model, service, state, and widget layers; executing the suite confirmed behaviour but surfaced external HTTP calls that should be isolated.

### Refactoring Performed

- None

### Compliance Check

- Coding Standards: ✓ No deviations spotted.
- Project Structure: ✓ Matches documented layout.
- Testing Strategy: ✗ Widget tests hit live tile servers; provide stubs to satisfy isolation guidance.
- All ACs Met: ✗ GraphHopper fallback exhausts the 5-second budget after OSRM timeouts, so AC3/AC4 fail under slow primary responses.

### Improvements Checklist

- [ ] Reserve part of the timeout window for GraphHopper so fallback executes after OSRM timeouts (lib/services/routing_service.dart).
- [ ] Stub tile requests in MapScreen widget tests to eliminate external HTTP dependency (test/screens/map_screen_test.dart).
- [ ] Add a regression test that simulates an OSRM timeout and verifies fallback success within 5 seconds.
- [ ] Document deployment expectations for configuring GRAPHHOPPER_API_KEY across environments.
- [ ] Capture performance telemetry around route calculation duration to validate the 5-second NFR.

### Security Review

- No new security concerns observed; all routing API calls remain HTTPS.

### Performance Considerations

- Current timeout budgeting gives OSRM the full 5 seconds, leaving no window for fallback execution and causing failures when the primary API hangs.

### Files Modified During Review

- None (QA review only).

### Gate Status

Gate: FAIL → docs/qa/gates/2.2-route-calculation-and-display.yml
Risk profile: docs/qa/assessments/2.2-risk-20251112.md (not generated)
NFR assessment: docs/qa/assessments/2.2-nfr-20251112.md (not generated)

### Recommended Status

✗ Changes Required - See unchecked items above
(Story owner decides final status)

### Review Date: 2025-11-12 (Re-review)

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

- Timeout budgeting now reserves capacity for GraphHopper, so routing completes within the 5-second SLA even when OSRM stalls.
- MapScreen widget tests use an in-memory tile provider, keeping the suite deterministic and fast; regression coverage verifies the fallback path.
- Implementation remains clean and aligned with architecture guidance; no new issues observed.

### Refactoring Performed

- None

### Compliance Check

- Coding Standards: ✓ No deviations spotted.
- Project Structure: ✓ Matches documented layout.
- Testing Strategy: ✓ Widget tests no longer hit live services; regression covers OSRM timeout fallback.
- All ACs Met: ✓ Fallback executes within budget, satisfying AC3/AC4 alongside existing criteria.

### Improvements Checklist

- [x] Reserve part of the timeout window for GraphHopper so fallback executes after OSRM timeouts (lib/services/routing_service.dart).
- [x] Stub tile requests in MapScreen widget tests to eliminate external HTTP dependency (test/screens/map_screen_test.dart).
- [x] Add a regression test that simulates an OSRM timeout and verifies fallback success within 5 seconds.
- [ ] Document deployment expectations for configuring GRAPHHOPPER_API_KEY across environments.
- [ ] Capture performance telemetry around route calculation duration to validate the 5-second NFR.

### Security Review

- All routing traffic remains on HTTPS; no new concerns.

### Performance Considerations

- Split timeout gives GraphHopper a guaranteed execution window, keeping end-to-end route calculation under 5 seconds.

### Tests Executed

- `flutter test test/models/route_test.dart test/services/routing_service_test.dart test/state/app_state_test.dart test/screens/map_screen_test.dart`

### Files Modified During Review

- None (QA review only).

### Gate Status

Gate: PASS → docs/qa/gates/2.2-route-calculation-and-display.yml
Risk profile: docs/qa/assessments/2.2-risk-20251112.md (not generated)
NFR assessment: docs/qa/assessments/2.2-nfr-20251112.md (not generated)

### Recommended Status

✓ Ready for Done
(Story owner decides final status)
